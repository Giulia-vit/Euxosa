import { addNamed } from '@babel/helper-module-imports';
import { isExportNamedDeclaration, isExportDefaultDeclaration, isFunctionDeclaration, variableDeclaration, variableDeclarator, functionExpression, isVariableDeclaration, isIdentifier, callExpression } from '@babel/types';
import { join, sep } from 'path';
import { types } from '@babel/core';

function functionDeclarationToExpression$1(declaration) {
  return types.functionExpression(declaration.id, declaration.params, declaration.body, declaration.generator, declaration.async);
}
function classDeclarationToExpression(declaration) {
  return types.classExpression(declaration.id, declaration.superClass, declaration.body, declaration.decorators);
}
function getFileName(state) {
  var filename = state.filename,
      cwd = state.cwd;

  if (!filename) {
    return undefined;
  }

  if (cwd && filename.startsWith(cwd)) {
    return filename.slice(cwd.length);
  }

  return filename;
}
function wrapExportDefaultDeclaration(path, HOFName, importFrom) {
  function wrapInHOF(path, expr) {
    return types.callExpression(addNamed(path, HOFName, importFrom), [expr]);
  }

  var node = path.node;

  if (types.isIdentifier(node.declaration) || types.isFunctionExpression(node.declaration) || types.isCallExpression(node.declaration)) {
    node.declaration = wrapInHOF(path, node.declaration);
  } else if (types.isFunctionDeclaration(node.declaration) || types.isClassDeclaration(node.declaration)) {
    if (node.declaration.id) {
      path.insertBefore(node.declaration);
      node.declaration = wrapInHOF(path, node.declaration.id);
    } else {
      if (types.isFunctionDeclaration(node.declaration)) {
        node.declaration = wrapInHOF(path, functionDeclarationToExpression$1(node.declaration));
      } else {
        node.declaration = wrapInHOF(path, classDeclarationToExpression(node.declaration));
      }
    }
  }
}

var _ref;

function functionDeclarationToExpression(declaration) {
  return functionExpression(declaration.id, declaration.params, declaration.body, declaration.generator, declaration.async);
}

var functionsToReplace = ['getServerSideProps', 'getStaticProps'];

function transformPropGetters(path, transform) {
  var node = path.node;

  if (isFunctionDeclaration(node.declaration)) {
    var functionId = node.declaration.id;

    if (!functionId) {
      return;
    }

    if (!functionsToReplace.includes(functionId.name)) {
      return;
    }

    node.declaration = variableDeclaration('const', [variableDeclarator(functionId, transform(functionDeclarationToExpression(node.declaration)))]);
    return;
  }

  if (isVariableDeclaration(node.declaration)) {
    node.declaration.declarations.forEach(function (declaration) {
      if (isIdentifier(declaration.id) && functionsToReplace.includes(declaration.id.name) && declaration.init) {
        declaration.init = transform(declaration.init);
      }
    });
  }
}

var HOFName = 'withFixNodeFileTrace';
var importFrom = 'next/dist/server/utils';

function addWithFixNodeFileTraceImport(path) {
  return addNamed(path, HOFName, importFrom);
}

var pagesToSkip = /*#__PURE__*/(_ref = []).concat.apply(_ref, /*#__PURE__*/['_app', '_document', '_error'].map(function (name) {
  return [name + '.js', name + '.jsx', name + '.ts', name + '.tsx'];
}));

function isPage(filePath) {
  if (!filePath.includes(sep + 'pages' + sep)) {
    return false;
  }

  if (filePath.includes(sep + 'pages' + sep + 'api' + sep)) {
    return false;
  }

  return !pagesToSkip.some(function (fileToSkip) {
    return filePath.includes(fileToSkip);
  });
}

function isApiRoute(filePath) {
  if (filePath.includes(sep + 'api' + sep)) {
    return true;
  }

  return false;
}

function FixNodeFileTrace() {
  return {
    name: 'FixNodeFileTrace',
    visitor: {
      Program: function Program(path, state) {
        var _getFileName;

        var filePath = (_getFileName = getFileName(state)) != null ? _getFileName : join('pages', 'Default.js');

        if (isPage(filePath)) {
          var body = path.get('body');
          body.filter(function (path) {
            return isExportNamedDeclaration(path);
          }).forEach(function (path) {
            transformPropGetters(path, function (decl) {
              return callExpression(addWithFixNodeFileTraceImport(path), [decl]);
            });
          });
          return;
        } else if (isApiRoute(filePath)) {
          var _body = path.get('body');

          var exportDefaultDeclaration = _body.find(function (path) {
            return isExportDefaultDeclaration(path);
          });

          if (exportDefaultDeclaration) {
            wrapExportDefaultDeclaration(exportDefaultDeclaration, HOFName, importFrom);
            return;
          }
        }
      }
    }
  };
} // eslint-disable-next-line import/no-default-export

/*
 * https://astexplorer.net/#/gist/dd0cdbd56a701d8c9e078d20505b3980/latest
 */
var defaultImportSource = 'next/stdlib';
var specialImports = {
  Link: 'next/link',
  Image: 'next/image',
  Script: 'next/script',
  Document: 'next/document',
  DocumentHead: 'next/document',
  Html: 'next/document',
  Main: 'next/document',
  BlitzScript: 'next/document',
  // AuthenticationError: 'next/stdlib',
  // AuthorizationError: 'next/stdlib',
  // CSRFTokenMismatchError: 'next/stdlib',
  // NotFoundError: 'next/stdlib',
  // PaginationArgumentError: 'next/stdlib',
  // RedirectError: 'next/stdlib',
  // formatZodError: 'next/stdlib',
  // recursiveFormatZodErrors: 'next/stdlib',
  // validateZodSchema: 'next/stdlib',
  // enhancePrisma: 'next/stdlib',
  // ErrorBoundary: 'next/stdlib',
  // withErrorBoundary: 'next/stdlib',
  // useErrorHandler: 'next/stdlib',
  // withBlitzAppRoot: 'next/stdlib',
  paginate: 'next/stdlib-server',
  isLocalhost: 'next/stdlib-server',
  invokeWithMiddleware: 'next/stdlib-server',
  passportAuth: 'next/stdlib-server',
  sessionMiddleware: 'next/stdlib-server',
  simpleRolesIsAuthorized: 'next/stdlib-server',
  getSession: 'next/stdlib-server',
  setPublicDataForUser: 'next/stdlib-server',
  SecurePassword: 'next/stdlib-server',
  hash256: 'next/stdlib-server',
  generateToken: 'next/stdlib-server',
  resolver: 'next/stdlib-server',
  getAntiCSRFToken: 'next/data-client',
  useSession: 'next/data-client',
  useAuthenticatedSession: 'next/data-client',
  useAuthorize: 'next/data-client',
  useQuery: 'next/data-client',
  usePaginatedQuery: 'next/data-client',
  useInfiniteQuery: 'next/data-client',
  useMutation: 'next/data-client',
  queryClient: 'next/data-client',
  getQueryKey: 'next/data-client',
  invalidateQuery: 'next/data-client',
  setQueryData: 'next/data-client',
  useQueryErrorResetBoundary: 'next/data-client',
  QueryClient: 'next/data-client',
  dehydrate: 'next/data-client',
  invoke: 'next/data-client',
  Head: 'next/head',
  App: 'next/app',
  dynamic: 'next/dynamic',
  noSSR: 'next/dynamic',
  getConfig: 'next/config',
  setConfig: 'next/config',
  ErrorComponent: 'next/error'
};

function RewriteImports(babel) {
  var t = babel.types;
  return {
    name: 'RewriteImports',
    visitor: {
      ImportDeclaration: function ImportDeclaration(path) {
        if (!looksLike(path, {
          node: {
            source: {
              value: 'blitz'
            }
          }
        })) {
          return;
        }

        path.node.source = t.stringLiteral(defaultImportSource);
        var specifierIndexesToRemove = [];
        path.node.specifiers.slice().forEach(function (specifier, index) {
          if (!t.isImportSpecifier(specifier)) return;
          var importedName = t.isStringLiteral(specifier.imported) ? specifier.imported.value : specifier.imported.name;

          if (importedName in specialImports) {
            path.insertAfter(t.importDeclaration([specifier], t.stringLiteral(specialImports[importedName])));
            specifierIndexesToRemove.push(index);
          }
        });
        specifierIndexesToRemove.reverse().forEach(function (index) {
          path.node.specifiers.splice(index, 1);
        });

        if (!path.node.specifiers.length) {
          path.remove();
        }
      }
    }
  };
}

function looksLike(a, b) {
  return a && b && Object.keys(b).every(function (bKey) {
    var bVal = b[bKey];
    var aVal = a[bKey];

    if (typeof bVal === 'function') {
      return bVal(aVal);
    }

    return isPrimitive(bVal) ? bVal === aVal : looksLike(aVal, bVal);
  });
}

function isPrimitive(val) {
  return val == null || /^[sbn]/.test(typeof val);
} // eslint-disable-next-line import/no-default-export

function preset(_api, options) {
  if (options === void 0) {
    options = {};
  }

  // const isTest = _api.env('test');
  var isRunningInJest = process.env.JEST_WORKER_ID && !process.env.__NEXT_TEST_MODE;
  var config = {
    presets: [[require('next/babel'), options]],
    plugins: [FixNodeFileTrace]
  };

  if (!isRunningInJest) {
    config.plugins.push(RewriteImports);
  }

  return config;
}

export default preset;
